# 1461 도서관 : 메모리 30616KB 시간 36ms

# 접근법
# 1. 걸음 수
#   1) 최대 들 수 있는 책의 수가 정해져 있다.
#      책을 가지러 x=0으로 돌아와야 한다.
#      => 걸음수 = 책의 위치 * 2
#   2) 책을 모두 정리한 후에 제자리로 돌아올 필요가 없다.
#      => 마지막 걸음수 = 책의 위치
# 2. 책 그룹화, 정리 순서
#   1) 거리를 최소화 하려면 근처의 책을 함께 옮겨야 한다.
#      => 가는 길에 속하는 좌표는 더할 필요가 없다.
#         (단, 한 번에 최대 m-1개까지 pass)
#   2) 가장 멀리 있는 위치는 반드시 들러야 하므로,
#      멀리 있는 책부터 근처의 m개씩 정리한다.
#      => 내림차순 정렬하여 0부터 m개 씩 pass한다.
#   3) 음수좌표와 양수좌표의 책은 방향이 정반대이므로 동시에 옮길 수 없다.
#      => 음수좌표와 양수좌표를 분리한다.

# num := 책의 총 개수
# max_w := 최대 옮길 수 있는 책의 수
num, max_w = list(map(int, input().split()))

# pos_ := 입력 받은 책의 좌표 (not sorted)
# pos := 음수[0]와 양수[1]로 분리한 책의 좌표 딕셔너리
pos_ = list(map(int, input().split()))
pos = {0: [0], 1: [0]}  # 책이 한 권도 없을 때, out of index 에러 예방
for i in range(num):
    pos[pos_[i] > 0].append(pos_[i])  # 음수이면 [0], 양수이면 [1]에 저장

# 책의 좌표를 정렬한다.
# 음수 좌표 : 오름차순 (가장 작은 값의 절댓값이 가장 크므로)
# 양수 좌표 : 내림차순 (가장 큰 값의 절댓값이 가장 크므로)
pos[0].sort()
pos[1].sort(reverse=True)

# step_count := 총 걸음 수
# line 44 : 모든 경로에 왕복(거리 * 2) 계산을 해주기 때문에
# line 42 : 마지막 경로(가장 큰 절댓값)가 왕복 계산되지 않도록 미리 빼준다.
# ㄴ pos[0]은 음수이므로 pos[0][0]
# ㄴ pos[1]은 양수이므로 -pos[1][0]
step_count = pos[0][0] if -pos[0][0] > pos[1][0] else -pos[1][0]
for i in range(0, len(pos[0]), max_w):  # 음수 좌표 경로의 걸음수 합산
    step_count += -pos[0][i] * 2

for i in range(0, len(pos[1]), max_w):  # 양수 좌표 경로의 걸음수 합산
    step_count += pos[1][i] * 2

print(step_count)