## 메모리 30616 KB 시간 36ms

n, k = map(int, input().split()) ## n,k 입력 받기
money =[] ## 입력받은 돈을 배열에 넣기
count =0  ## k를 만들기 위해 필요한 동전 개수의 최솟값

for _ in range(n): ## 반복문을 n 만큼 돌면서
    money.append(int(input()))  ## 동전의 가치를 입력받는다.

for i in reversed(range(n)):  ## 반복문을 n 만큼 도는데, 이때 입력받은 돈이 오름차순이므로
    # 내림차순으로 바꾸기 위해 reversed를 사용해서 반복문 읽는 순서를 내림차순으로 바꾼다.
    ## 안그러면 런타임 에러뜸
    # 1. 배열에 할당된 크기를 넘어서 접근할 때 (내가 이때 해당함. reversed를 안쓰고 money[n-i-1]로 접근하면  n=1일때 에러 발생)
    # 2. 0으로 나눌때
    # 3. 라이브러이에서 예외 발생시켰을 때
    # 4. 재귀호출이 너무 깊어질때
    # 5. 이미 해제된 메모리를 또 참조할 때

    count += k // money[i]  ## k를 입력된 돈에서 가장 큰 돈으로 나눠서 나온 몫을 count에 저장
    k = k % money[i] ## 나머지를 k로 다시 저장해서 위 작업을 계속 반복


print(count)